package com.carbondev.carboncheck.presentation.content.viewmodel

import androidx.lifecycle.viewModelScope
import com.carbondev.carboncheck.data.remote.CarbonInterfaceDataSource
import com.carbondev.carboncheck.data.remote.model.request.NetworkFlightLeg
import com.carbondev.carboncheck.data.remote.model.request.NetworkFlightRequest
import com.carbondev.carboncheck.domain.common.ActivityType
import com.carbondev.carboncheck.domain.common.Result
import com.carbondev.carboncheck.domain.model.Activity
import com.carbondev.carboncheck.domain.model.CarbonData
import com.carbondev.carboncheck.domain.usecase.activity.AddActivityUseCase
import com.carbondev.carboncheck.presentation.common.viewmodel.BaseViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import kotlinx.datetime.Clock
import timber.log.Timber
import javax.inject.Inject

/**
 * ViewModel for the ActivityFormPage.
 * It handles the state and logic for creating and saving a new activity.
 */
@HiltViewModel
class ActivityFormViewModel @Inject constructor(
    private val addActivityUseCase: AddActivityUseCase,
    private val carbonInterfaceDataSource: CarbonInterfaceDataSource
) : BaseViewModel() {

    /**
     * Creates and saves a new Car activity.
     * This function would be called from the "Save" button in the CarActivityForm.
     */
    fun saveCarActivity(distanceKm: String, vehicleType: String) {
        viewModelScope.launch {
            setLoading()
            val distance = distanceKm.toIntOrNull()
            if (distance == null) {
                setError("Invalid distance entered.")
                return@launch
            }

            // In a real app, you would have another use case to calculate this
            // based on the distance and vehicle type. For now, we'll use a placeholder.
            val estimatedCarbon = when (vehicleType) {
                "Petrol" -> CarbonData.fromKilograms(distance * 0.12)
                "Diesel" -> CarbonData.fromKilograms(distance * 0.2)
                "Electric" -> CarbonData.fromKilograms(distance * 0.05)
                else -> CarbonData.fromKilograms(0.0)
            }

            val newActivity = Activity(
                id = "", // Will be generated by the server
                userId = "", // Will be set by the server-side logic
                type = ActivityType.TRANSPORT,
                datetime = Clock.System.now(),
                carbon = estimatedCarbon,
                distance = distance,
                vehicleType = vehicleType,
                flightDeparture = null,
                flightDestination = null,
                people = null,
                foodType = null,
                weightInGrams = null
            )

            handleSubmit(newActivity)
        }
    }

    /**
     * Creates and saves a new Flight activity.
     */
    fun saveFlightActivity(departure: String, destination: String, people: String) {
        viewModelScope.launch {
            setLoading()
            val peopleCount = people.toIntOrNull()
            if (peopleCount == null || peopleCount <= 0) {
                setError("Invalid number of people.")
                return@launch
            }

            // Step 1: Build the request for the Carbon Interface API
            val flightRequest = NetworkFlightRequest(
                passengers = peopleCount,
                legs = listOf(
                    NetworkFlightLeg(
                        departureAirport = departure,
                        destinationAirport = destination
                    )
                ),
            )

            // Step 2: Call the new data source to get the estimation
            val flightAttribute = carbonInterfaceDataSource.getFlightCarbonEstimation(flightRequest)

            if (flightAttribute == null) {
                setError("Could not calculate carbon emissions. Please try again.")
                return@launch
            }

            // Step 3: Create the Activity object with the real carbon data
            val carbonData = CarbonData(gram = flightAttribute.carbonG.toDouble())
            val newActivity = Activity(
                id = "",
                userId = "",
                type = ActivityType.FLIGHT,
                datetime = Clock.System.now(),
                carbon = carbonData,
                flightDeparture = departure,
                flightDestination = destination,
                people = peopleCount,
                distance = flightAttribute.distanceValue.toInt(),
                vehicleType = null,
                foodType = null,
                weightInGrams = null
            )

            // Step 4: Proceed with the existing save logic
            handleSubmit(newActivity)
        }
    }

    /**
     * Creates and saves a new Food activity.
     */
    fun saveFoodActivity(weightGrams: String, foodType: String) {
        viewModelScope.launch {
            setLoading()
            val weight = weightGrams.toIntOrNull()
            if (weight == null) {
                setError("Invalid weight entered.")
                return@launch
            }

            // Placeholder carbon calculation
            val estimatedCarbon = when (foodType) {
                "Chicken" -> CarbonData.fromGrams(weight * 6.9)
                "Beef" -> CarbonData.fromGrams(weight * 27.0)
                else -> CarbonData.fromGrams(0.0)
            }

            val newActivity = Activity(
                id = "",
                userId = "",
                type = ActivityType.FOOD,
                datetime = Clock.System.now(),
                carbon = estimatedCarbon,
                foodType = foodType,
                weightInGrams = weight,
                distance = null,
                vehicleType = null,
                flightDeparture = null,
                flightDestination = null,
                people = null
            )

            handleSubmit(newActivity)
        }
    }

    /**
     * The final step that calls the use case and handles the result.
     */
    private suspend fun handleSubmit(activity: Activity) {
        when (val result = addActivityUseCase(activity)) {
            is Result.Success -> {
                // You can set a specific success state if you want the UI
                // to show a message before navigating.
                Timber.d("Activity saved successfully!")
                setSuccess(true) // Signals to the UI to navigate back or show success
            }
            is Result.Error -> {
                setError(result.message ?: "An unknown error occurred.")
                Timber.e("Error saving activity: ${result.message}")
            }
        }
    }
}